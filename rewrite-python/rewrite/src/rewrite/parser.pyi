# Auto-generated stub file for IDE autocomplete support.
# Do not edit manually - regenerate with: python scripts/generate_stubs.py

from dataclasses import dataclass
from typing import Any, ClassVar, List, Optional, TypeVar, Generic
from typing_extensions import Self
from uuid import UUID
import weakref

P = TypeVar('P')

from abc import ABC, abstractmethod
from pathlib import Path

class Parser(ABC):
    def parse_inputs(self, sources: Iterable[ParserInput], relative_to: Optional[Path], ctx: ExecutionContext) -> Iterable[SourceFile]: ...
    def accept(self, path: Path) -> bool: ...
    def source_path_from_source_text(self, prefix: Path, source_code: str) -> Path: ...
    def parse(self, source_files: Iterable[Path], relative_to: Optional[Path], ctx: ExecutionContext) -> Iterable[SourceFile]: ...
    def parse_strings(self) -> Iterable[SourceFile]: ...
    def accept_input(self, parser_input: ParserInput) -> bool: ...
    def accepted_inputs(self, inputs: Iterable[ParserInput]) -> Iterable[ParserInput]: ...
    def get_charset(self, ctx: ExecutionContext) -> str: ...

class ParserBuilder(ABC):
    @property
    def source_file_type(self) -> type: ...
    @property
    def dsl_name(self) -> Optional[str]: ...
    def build(self) -> Parser: ...

@dataclass(frozen=True)
class ParserInput:
    _path: Path
    _file_attributes: Optional[FileAttributes]
    _synthetic: bool
    _source: Callable[[], IO[Any]]

    def replace(self, **kwargs: Any) -> Self: ...

    @property
    def path(self) -> Path: ...
    @property
    def file_attributes(self) -> Optional[FileAttributes]: ...
    @property
    def synthetic(self) -> bool: ...
    @property
    def source(self) -> Callable[[], IO[Any]]: ...

@dataclass(frozen=True)
class ParseError(SourceFile):
    _id: UUID
    _markers: Markers
    _source_path: Path
    _file_attributes: Optional[FileAttributes]
    _charset_name: Optional[str]
    _charset_bom_marked: bool
    _checksum: Optional[Checksum]
    _text: str
    _erroneous: Optional[SourceFile]

    def replace(self, **kwargs: Any) -> Self: ...

    @classmethod
    def build(cls, parser: 'Parser', input: ParserInput, relative_to: Optional[Path], ctx: ExecutionContext, exception: Exception, erroneous: Optional[SourceFile]) -> 'ParseError': ...

    @property
    def id(self) -> UUID: ...
    @property
    def markers(self) -> Markers: ...
    @property
    def source_path(self) -> Path: ...
    @property
    def file_attributes(self) -> Optional[FileAttributes]: ...
    @property
    def charset_name(self) -> Optional[str]: ...
    @property
    def charset_bom_marked(self) -> bool: ...
    @property
    def checksum(self) -> Optional[Checksum]: ...
    @property
    def text(self) -> str: ...
    @property
    def erroneous(self) -> Optional[SourceFile]: ...

    def with_id(self, id: UUID) -> 'ParseError': ...
    def with_markers(self, markers: Markers) -> 'ParseError': ...
    def with_source_path(self, source_path: Path) -> 'ParseError': ...
    def with_file_attributes(self, file_attributes: Optional[FileAttributes]) -> 'ParseError': ...
    def with_charset_name(self, charset_name: Optional[str]) -> 'ParseError': ...
    def with_charset_bom_marked(self, charset_bom_marked: bool) -> 'ParseError': ...
    def with_checksum(self, checksum: Optional[Checksum]) -> 'ParseError': ...
    def with_text(self, text: str) -> 'ParseError': ...
    def with_erroneous(self, erroneous: Optional[SourceFile]) -> 'ParseError': ...
    def printer(self, cursor: Cursor) -> TreeVisitor[Tree, PrintOutputCapture[P]]: ...
    def is_acceptable(self, v: TreeVisitor[Any, P], p: P) -> bool: ...
    def accept(self, v: TreeVisitor[Any, P], p: P) -> Optional[Any]: ...
