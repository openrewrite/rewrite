# Copyright 2025 the original author or authors.
#
# Licensed under the Moderne Source Available License (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://docs.moderne.io/licensing/moderne-source-available-license
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
pytest configuration and fixtures for OpenRewrite Python tests.

This module provides fixtures for testing Python recipes, including
support for recipes that delegate to Java via RPC.
"""

import csv
import os
import pytest
from pathlib import Path
from typing import List, Optional

# Try to import Java RPC client (may not be available in minimal installs)
try:
    from rewrite.rpc.java_rpc_client import (
        JavaRpcClient,
        set_java_rpc_client,
        install_java_rpc_hooks,
    )
    JAVA_RPC_AVAILABLE = True
except ImportError:
    JAVA_RPC_AVAILABLE = False


def find_test_classpath() -> Optional[str]:
    """
    Find the Java test classpath for RPC server.

    Looks for the classpath in these locations (in order):
    1. REWRITE_PYTHON_CLASSPATH environment variable
    2. test-classpath.txt file generated by Gradle

    Returns:
        The classpath string, or None if not found
    """
    # Check environment variable first
    classpath = os.environ.get("REWRITE_PYTHON_CLASSPATH")
    if classpath:
        return classpath

    # Look for generated classpath file
    # Try various relative paths depending on where tests are run from
    search_paths = [
        Path("test-classpath.txt"),
        Path("rewrite/test-classpath.txt"),
        Path(__file__).parent.parent / "test-classpath.txt",
        Path(__file__).parent.parent.parent / "test-classpath.txt",
    ]

    for path in search_paths:
        if path.exists():
            return path.read_text().strip()

    return None


def create_marketplace_csv(recipes: List[dict], output_path: Path) -> Path:
    """
    Create a marketplace CSV file for the given recipes.

    Args:
        recipes: List of dicts with recipe metadata. Each dict should have:
            - name: Recipe fully qualified name
            - packageName: Maven group:artifact (e.g., "org.openrewrite:rewrite-java")
            - version: Package version
            - displayName: (optional) Human-readable name
            - description: (optional) Recipe description
        output_path: Path to write the CSV file

    Returns:
        Path to the created CSV file
    """
    with open(output_path, 'w', newline='') as f:
        writer = csv.writer(f)
        # Write header
        writer.writerow(['name', 'displayName', 'description', 'ecosystem', 'packageName', 'version'])

        for recipe in recipes:
            writer.writerow([
                recipe['name'],
                recipe.get('displayName', recipe['name']),
                recipe.get('description', ''),
                'maven',  # Always Maven for Java recipes
                recipe['packageName'],
                recipe['version'],
            ])

    return output_path


@pytest.fixture(scope="session")
def java_rpc_classpath() -> Optional[str]:
    """
    Fixture providing the Java classpath for RPC server.

    Returns None if classpath is not available, which will cause
    java_rpc_client fixture to skip tests that require Java RPC.
    """
    return find_test_classpath()


@pytest.fixture(scope="module")
def java_marketplace_csv(request, tmp_path_factory) -> Path:
    """
    Fixture that creates a marketplace CSV for the test module.

    Test modules can customize the recipes by defining a `java_recipes` fixture
    or `JAVA_RECIPES` module variable:

        JAVA_RECIPES = [
            {
                'name': 'org.openrewrite.java.ChangeType',
                'packageName': 'org.openrewrite:rewrite-java',
                'version': '8.73.0',
            },
        ]

    Or as a fixture:

        @pytest.fixture(scope="module")
        def java_recipes():
            return [
                {'name': 'org.openrewrite.java.ChangeType', ...},
            ]
    """
    # Try to get recipes from fixture
    recipes = None
    if hasattr(request, 'fixturenames') and 'java_recipes' in request.fixturenames:
        recipes = request.getfixturevalue('java_recipes')

    # Try to get recipes from module variable
    if recipes is None and hasattr(request.module, 'JAVA_RECIPES'):
        recipes = request.module.JAVA_RECIPES

    # Default recipes for common Java recipe wrappers
    if recipes is None:
        recipes = [
            {'name': 'org.openrewrite.java.ChangeType',
             'packageName': 'org.openrewrite:rewrite-java', 'version': '8.73.0'},
            {'name': 'org.openrewrite.java.ChangeMethodName',
             'packageName': 'org.openrewrite:rewrite-java', 'version': '8.73.0'},
            {'name': 'org.openrewrite.java.ChangePackage',
             'packageName': 'org.openrewrite:rewrite-java', 'version': '8.73.0'},
            {'name': 'org.openrewrite.java.DeleteMethodArgument',
             'packageName': 'org.openrewrite:rewrite-java', 'version': '8.73.0'},
            {'name': 'org.openrewrite.java.ReorderMethodArguments',
             'packageName': 'org.openrewrite:rewrite-java', 'version': '8.73.0'},
            {'name': 'org.openrewrite.java.AddLiteralMethodArgument',
             'packageName': 'org.openrewrite:rewrite-java', 'version': '8.73.0'},
        ]

    # Create marketplace CSV
    csv_dir = tmp_path_factory.mktemp("marketplace")
    csv_path = csv_dir / "marketplace.csv"
    return create_marketplace_csv(recipes, csv_path)


@pytest.fixture(scope="module")
def java_rpc_client(java_rpc_classpath, java_marketplace_csv, tmp_path_factory):
    """
    Fixture providing a Java RPC client for testing.

    This fixture starts a Java RPC server process and provides a client
    for communicating with it. The server runs for the entire test module.

    Tests that require Java RPC (e.g., those using ChangeType, AddLiteralMethodArgument)
    should request this fixture. If Java RPC is not available, the test will be skipped.

    Usage:
        def test_change_type(java_rpc_client):
            # Java RPC is now available for recipes that delegate to Java
            spec = RecipeSpec(recipe=ChangeType(...))
            spec.rewrite_run(python("...", "..."))
    """
    if not JAVA_RPC_AVAILABLE:
        pytest.skip("Java RPC client module not available")

    if not java_rpc_classpath:
        pytest.skip(
            "Java RPC classpath not available. "
            "Run './gradlew :rewrite-python:generateTestClasspath' first, "
            "or set REWRITE_PYTHON_CLASSPATH environment variable."
        )

    # Create log directory
    log_dir = tmp_path_factory.mktemp("java_rpc_logs")
    log_file = log_dir / "java-rpc-server.log"

    # Start Java RPC client
    client = JavaRpcClient(
        marketplace_csv=java_marketplace_csv,
        java_classpath=java_rpc_classpath,
        log_file=log_file,
        trace=os.environ.get("REWRITE_RPC_TRACE", "").lower() in ("1", "true", "yes"),
        timeout=60.0,
    )

    try:
        client.start()

        # Install hooks so Python RPC calls go to Java
        set_java_rpc_client(client)
        install_java_rpc_hooks()

        yield client

    finally:
        # Cleanup
        set_java_rpc_client(None)
        client.shutdown()

        # Print log file on failure (helpful for debugging)
        if log_file.exists():
            log_content = log_file.read_text()
            if log_content:
                print(f"\n=== Java RPC Server Log ===\n{log_content}")


@pytest.fixture
def java_rpc(java_rpc_client):
    """
    Convenience fixture that just ensures Java RPC is available.

    Use this when you need Java RPC but don't need direct access to the client.

    Usage:
        def test_something(java_rpc):
            # Java RPC is available
            pass
    """
    return java_rpc_client


# Marker for tests that require Java RPC
def pytest_configure(config):
    """Register custom markers."""
    config.addinivalue_line(
        "markers",
        "requires_java_rpc: mark test as requiring Java RPC server"
    )


def pytest_collection_modifyitems(config, items):
    """Skip tests marked with requires_java_rpc if Java RPC is not available."""
    if not JAVA_RPC_AVAILABLE:
        skip_java_rpc = pytest.mark.skip(reason="Java RPC not available")
        for item in items:
            if "requires_java_rpc" in item.keywords:
                item.add_marker(skip_java_rpc)
    elif not find_test_classpath():
        skip_classpath = pytest.mark.skip(
            reason="Java RPC classpath not configured (run ./gradlew :rewrite-python:generateTestClasspath)"
        )
        for item in items:
            if "requires_java_rpc" in item.keywords:
                item.add_marker(skip_classpath)
